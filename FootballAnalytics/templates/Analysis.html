<!DOCTYPE html>
<html lang="en" xmlns="http://www.w3.org/1999/html">
<head>
    <link href='https://fonts.googleapis.com/css?family=Staatliches' rel='stylesheet'>
    <link href='https://fonts.googleapis.com/css?family=Thasadith' rel='stylesheet'>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>HardlyBaflin</title>
    <style>
        body {
            display: flex;
            flex-direction: column;
            margin: 0;
            padding: 0;
            font-family: Helvetica;
        }

        .header {
            background-color: #fcfcfc;
            padding: 10px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            top: 0;
            left: 0;
            z-index: 999;
        }

        .header h1 {
            background-color: white;
            margin: 0;
            color:  #ff0019;
            font-size: 50px;
            font-family: Staatliches;
            font-weight: 300;
        }

        .header h2 {
            background-color: white;
            margin: 0;
            color:  #ff0019;
        }

        .contact {
            display: flex;
            align-items: center;
        }

        .contact a {
            font-size: 18px;
            text-decoration: none;
            padding-left: 10px;
            color: black;
        }

        .contact img {
            width: 50px;
            margin-right: -8px;
            vertical-align: middle;
            padding: 3px;
        }

        .content {
            display: flex;
            flex-direction: row;
        }

        .sidebar {
            background-color: #f3f3f3;
            color: black;
            width: 160px;
            font-size: 15px;
            padding: 6px;
            display: flex;
            flex-direction: column;
            justify-content: flex-start;
            align-items: center;
            min-height: 100vh;
            position: fixed;
            top: 0;
            left: 0;
            z-index: 998;
        }

        .sidebar ul {
            list-style-type: none;
            padding: 0px;
            margin-top: 110px;
        }

        .sidebar li {
            margin-bottom: -49px;
            margin-top: 80px;
        }

        .sidebar a {
            color: black;
            text-decoration: none;
        }

        .sidebar a:hover,
        .sidebar a.active {
            background-color: #ff0019;
            color: white;
            padding: 10px;
            border-radius: 3px;
        }

        .main-content {
            flex: 1;
            padding: 40px;
            margin-top: 30px;
            justify-content: center;
            align-items: center;
            font-size: 16px;
            margin-left: 180px;
        }

        .progress-bar {
            width: 0%;
            height: 5px;
            background-color: #00ff97;
            position: fixed;
            top: 0;
            left: 0;
            z-index: 9999;
        }

        .handle-value {
            font-size: 22px;
            padding-bottom: 12px;
            margin-top: -3px;
        }

        .noUi-horizontal .noUi-handle {
            margin-top: -3px;
            box-shadow: 0 0 4px rgba(0, 0, 0, 0.5);
            width: 2px;
        }

        .higher {
            background-color: #008C64;
            box-shadow: 0 0 4px rgba(0, 0, 0, 0.5);
            display: inline-block;
            width: 67px;
            height: 33px;
            line-height: 33px;
            text-align: center;
            font-size: 17px;
            color: white;
        }

        .lower {
            background-color: #FF2848;
            box-shadow: 0 0 4px rgba(0, 0, 0, 0.5);
            display: inline-block;
            width: 67px;
            height: 33px;
            line-height: 33px;
            text-align: center;
            font-size: 17px;
            color: white;
        }

        .slider-container {
            margin: auto;
            font-family: Staatliches;
            text-align: center;
            width: 340px;
            padding-top: 6px;
            padding-left: 26px;
            padding-right: 26px;
            padding-bottom: 18px;
            z-index: 1000;
            background-color: 'white';
            box-shadow: 0 0 1px rgba(0, 0, 0, 0.5);
        }
        .grid {
          position: relative;
          display: inline-block;
        }
        .grid-sum-value {
          position: absolute;
          display: none;
          background-color: rgba(255, 255, 255, 0.8);
          color: black;
          padding: 4px;
          border-radius: 4px;
          font-size: 14px;
          z-index: 3;
        }
    </style>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/noUiSlider/14.7.0/nouislider.min.css">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/noUiSlider/14.7.0/nouislider.min.js"></script>
    <script src="https://d3js.org/d3.v5.min.js"></script>
</head>
<body>
    <div class="header">
        <h1>HardlyBaflin</h1>
        <div class="contact">
            <a class="twitter" href="https://twitter.com/Sam_Maflin">
                <img src="/static/twitter.png" alt="Twitter Logo">
            </a>
            <a class="email" href="mailto:s.maflin@outlook.com">
                <img src="/static/email.png" alt="Email Icon">
            </a>
        </div>
    </div>
    <div class="content">
        <div class="sidebar">
            <ul>
                <li><a href="/">Home</a></li>
                <li><a href="/Acknowledgement">Acknowledgment</a></li>
                <li><a href="/LetsGetStarted">Let's Get Started...</a></li>
                <li><a href="/Analysis" class="active">Match Analysis</a></li>
            </ul>
        </div>
        <div class="main-content">
            <h1 style="margin-top: 60px; padding-bottom: 30px; font-size: 80px; font-family: Staatliches;
            font-weight: 300;">Match Statistics</h1>
            <h2>Let's start simple.</h2>
            <p style="text-align: justify; line-height: 1.7;">
                An easy yet useful way to gain an initial understanding of how the
                outcome of a particular football match may have been determined is
                to assess the summary statistics of the match. In particular, statistics
                that can readily indicate a significant shift in the game's dynamics, such
                as goals and red cards. Other widely recognized statistics include
                possession, shots, and shots on target. These metrics offer a concise and
                informative perspective for viewers, indicating the team that
                potentially held dominance over the opposition. They provide a
                degree of certainty regarding which team is more likely to create and
                capitalize on goal-scoring opportunities.
            </p>
            <p style="text-align: justify; line-height: 1.7; padding-top: 14px;">
                However, do we perhaps overly rely on these traditional statistics to
                gauge a team's dominance? What happens when these numbers are
                tightly contested, and the narrative becomes less clear? That's when
                we consider more nuanced metrics that attempt to look beyond the
                surface to provide potential reasoning behind how teams create scoring
                opportunities, unlock defenses, and ultimately sway the course of a
                match. Of course, no single metric can possibly hold all the answers.
                Instead, it's the collective power of these metrics combined that
                enhances our understanding. Nevertheless, for now, we'll set aside
                the traditional metrics and instead focus on the more nuanced ones,
                such as <em>Expected Goals (xG), Expected Threat (xT), Valuing Actions
                by Estimating Probabilities (VAEP)</em>, and <em>Passes Per Defensive Action
                (PPDA)</em>, to mention only a few.
            </p>
            <div style="text-align: center; margin-top: 80px; margin-bottom: 40px; font-family: Staatliches;">
                <table style="margin: 0 auto; width: 67%">
                    <tr>
                        <th style="color: black; font-size: 44px; font-weight: normal; text-align: center; margin-left: 10px; width: 30%;">{{ hteam }}</th>
                        <th style="color: black; font-size: 44px; font-weight: normal; text-align: center; padding: 3px; width: 40%;">
                            <span id="hteam-score">{{ hteam_score }}</span>-<span id="ateam-score">{{ ateam_score }}</span>
                        </th>
                        <th style="color: black; font-size: 44px; font-weight: normal; text-align: center; width: 30%;">{{ ateam }}</th>
                    </tr>
                    <tr>
                        <td style="color: black; font-size: 12px; text-align: center; width: 30%;">
                            <span id="hteam-scorers">{{ hteam_scorers }}</span>
                        </td>
                        <td style="width: 40%;"></td>
                        <td style="color: black; font-size: 12px; text-align: center; width: 30%;">
                            <span id="ateam-scorers">{{ ateam_scorers }}</span>
                        </td>
                    </tr>
                    <tr>
                        <td colspan="3" style="color: black; font-size: 24px; text-align: center; width: 30%; margin-top: -7px; margin-bottom: -30px;">Match Period
                        </td>
                    </tr>
                    <tr>
                        <td colspan="3">
                            <div class="slider-container" id="slider-container">
                                <div class="handle-value" id="handle-label-0"></div>
                                <div class="handle-value" id="handle-label-1"></div>
                                <div id="minute-slider" style="height: 12px;"></div>
                            </div>
                        </td>
                    </tr>
                    <tr>
                        <td style="color: black; text-align: center; width: 30%; font-size: 17px;">
                            <span id="hteam-xg">{{ hteam_xg }}</span>
                        </td>
                        <td style="color: black; text-align: center; width: 30%; padding: 3px; font-size: 17px;">
                            Expected Goals (xG)
                        </td>
                        <td style="color: black; text-align: center; width: 30%; padding: 3px; font-size: 17px;">
                            <span id="ateam-xg">{{ ateam_xg }}</span>
                        </td>
                    </tr>
                    <tr>
                        <td style="color: black; text-align: center; width: 30%; padding: 3px; font-size: 17px;">
                            <span id="hteam-opxg">{{ hteam_opxg }}</span>
                        </td>
                        <td style="color: black; text-align: center; width: 30%; padding: 3px; font-size: 17px;">
                            Open Play Expected Goals
                        </td>
                        <td style="color: black; text-align: center; width: 30%; padding: 3px; font-size: 17px;">
                            <span id="ateam-opxg">{{ ateam_opxg }}</span>
                        </td>
                    </tr>
                    <tr>
                        <td style="color: black; text-align: center; width: 30%; padding: 3px; font-size: 17px;">
                            <span id="hteam-spxg">{{ hteam_spxg }}</span>
                        </td>
                        <td style="color: black; text-align: center; width: 30%; padding: 3px; font-size: 17px;">
                            Set Piece Expected Goals
                        </td>
                        <td style="color: black; text-align: center; width: 30%; padding: 3px; font-size: 17px;">
                            <span id="ateam-spxg">{{ ateam_spxg }}</span>
                        </td>
                    </tr>
                    <tr>
                        <td style="color: black; text-align: center; width: 30%; padding: 3px; font-size: 17px;">
                            <span id="hteam-shot">{{ hteam_shot }}</span>
                        </td>
                        <td style="color: black; text-align: center; width: 30%; padding: 3px; font-size: 17px;">
                            Total Shots
                        </td>
                        <td style="color: black; text-align: center; width: 30%; padding: 3px; font-size: 17px;">
                            <span id="ateam-shot">{{ ateam_shot }}</span>
                        </td>
                    </tr>
                    <tr>
                        <td style="color: black; text-align: center; width: 30%; padding: 3px; font-size: 17px;">
                            <span id="hteam-shotot">{{ hteam_shotot }}</span>
                        </td>
                        <td style="color: black; text-align: center; width: 30%; padding: 3px; font-size: 17px;">
                            Shots On Target
                        </td>
                        <td style="color: black; text-align: center; width: 30%; padding: 3px; font-size: 17px;">
                            <span id="ateam-shotot">{{ ateam_shotot }}</span>
                        </td>
                    </tr>
                    <tr>
                        <td style="color: black; text-align: center; width: 30%; padding: 3px; font-size: 17px;">
                            <span id="hteam-redcard">{{ hteam_redcard }}</span>
                        </td>
                        <td style="color: black; text-align: center; width: 30%; padding: 3px; font-size: 17px;">
                            Red Cards
                        </td>
                        <td style="color: black; text-align: center; width: 30%; padding: 3px; font-size: 17px;">
                            <span id="ateam-redcard">{{ ateam_redcard }}</span>
                        </td>
                    </tr>
                    <tr>
                        <td style="color: black; text-align: center; width: 30%; padding: 3px; font-size: 17px;">
                            <span id="hteam-poss">{{ hteam_possession }}</span>
                        </td>
                        <td style="color: black; text-align: center; width: 30%; padding: 3px; font-size: 17px;">
                            Possession
                        </td>
                        <td style="color: black; text-align: center; width: 30%; padding: 3px; font-size: 17px;">
                            <span id="ateam-poss">{{ ateam_possession }}</span>
                        </td>
                    </tr>
                    <tr>
                        <td style="color: black; text-align: center; width: 30%; padding: 3px; font-size: 17px;">
                            <span id="hteam-pass">{{ hteam_pass }}</span>
                        </td>
                        <td style="color: black; text-align: center; width: 30%; padding: 3px; font-size: 17px;">
                            Passes
                        </td>
                        <td style="color: black; text-align: center; width: 30%; padding: 3px; font-size: 17px;">
                            <span id="ateam-pass">{{ ateam_pass }}</span>
                        </td>
                    </tr>
                    <tr>
                        <td style="color: black; text-align: center; width: 30%; padding: 3px; font-size: 17px;">
                            <span id="hteam-accpass">{{ hteam_accpass }}</span>
                        </td>
                        <td style="color: black; text-align: center; width: 30%; padding: 3px; font-size: 17px;">
                            Pass Accuracy
                        </td>
                        <td style="color: black; text-align: center; width: 30%; padding: 3px; font-size: 17px;">
                            <span id="ateam-accpass">{{ ateam_accpass }}</span>
                        </td>
                    </tr>
                    <tr>
                        <td style="color: black; text-align: center; width: 30%; padding: 3px; font-size: 17px;">
                            <span id="hteam-ftentries">{{ hteam_ftentries }}</span>
                        </td>
                        <td style="color: black; text-align: center; width: 30%; padding: 3px; font-size: 17px;">
                            Final Third Entries
                        </td>
                        <td style="color: black; text-align: center; width: 30%; padding: 3px; font-size: 17px;">
                            <span id="ateam-ftentries">{{ ateam_ftentries }}</span>
                        </td>
                    </tr>
                    <tr>
                        <td style="color: black; text-align: center; width: 30%; padding: 3px; font-size: 17px;">
                            <span id="hteam-pbentries">{{ hteam_pbentries }}</span>
                        </td>
                        <td style="color: black; text-align: center; width: 30%; padding: 3px; font-size: 17px;">
                            Penalty Box Entries
                        </td>
                        <td style="color: black; text-align: center; width: 30%; padding: 3px; font-size: 17px;">
                            <span id="ateam-pbentries">{{ ateam_pbentries }}</span>
                        </td>
                    </tr>
                </table>
            </div>
            <hr style="margin-bottom: 80px">
            <h1 style="padding-bottom: 15px; font-size: 50px; font-family: Staatliches;
            font-weight: 300;">Expected Goals (xG)</h1>
                <p style="text-align: justify; line-height: 1.7; padding-top: 18px;">
                    One of the most well-known and widely recognized metrics we'll
                    explore is xG, short for Expected Goals. xG goes beyond traditional
                    metrics like shots and shots on target, providing a more
                    comprehensive assessment of goal-scoring opportunities. By
                    calculating the probability of a player scoring from a specific location
                    on the pitch, xG offers valuable insight into the quality and potential
                    outcome of each scoring chance. Unlike simple shot counts, xG
                    estimates the likelihood of a goal being scored from a given location
                    based on account several factors:
                </p>
                <ul style="text-align: justify; line-height: 1.7; padding-top: 12px; padding-bottom: 10px;">
                    <li>Distance to the goal</li>
                    <li>Angle to the goal</li>
                    <li>Body part (eg. Header or foot)</li>
                    <li>Goalkeeper's position</li>
                    <li>One-on-one</li>
                    <li>Type of assist (through ball, cross, cut-back)</li>
                </ul>
            <p style="text-align: justify; line-height: 1.7; padding-top: 12px;">
                The question is, how can we communicate xG visually to reveal which
                team reigns supreme in goal-scoring opportunities? The answer lies in
                creating engaging data visualisation, AKA Pie charts! Just ask yourself, who
                doesn't love a Pie chart? That's correct... absolutely everybody. Oh, and
                to those of you who haven't seen Pie charts or worse might believe
                that they are in fact useful, they are one of humanities most meaningless
                creations. The remainder of this section should perhaps focus on why
                this is evidently true, but let's return to xG instead before it's too late.
            </p>
            <p style="text-align: justify; line-height: 1.7; padding-top: 12px; padding-bottom:35px;">
                xG Shots Maps and Timelines are certainly more typical illustrations
                deployed when analysing xG performance. Shot Maps showcase which
                team generated higher-value scoring chances and identify the specific
                areas of the field where they were concentrated. Alternatively, timelines
                provide a chronological view of the progression of xG values throughout
                the match. Spikes or dips in xG values over time identify key moments
                when one team had a higher probability of scoring compared to the other,
                building a clearer narrative of which team maximized their opportunities
                by converting chances into goals.
            </p>
            <h2 style="padding-top: 22px; font-size: 24px; text-align: center; font-family: Staatliches;">xG Shot Map</h2>
            <div style="display: flex; font-family: Staatliches; gap: 5px; font-size: 16px; font-weight: bold; align-items: center; justify-content: center;">
                <script src="https://d3js.org/d3.v7.min.js"></script>
                <label for="team-select">Team:</label>
                <select id="team-select">
                    <option value="">All Teams</option>
                </select>
                <label for="shot-type-select">Shot Outcome:</label>
                <select id="shot-type-select">
                    <option value="">All Shot Types</option>
                </select>
                <label for="player-select">Player:</label>
                <select id="player-select">
                    <option value="">All Players</option>
                </select>
            </div>
            <div id="plot-container" style="display: flex; gap: 5px; align-items: center; justify-content: center; font-family: Staatliches;"></div>
            <div id="line-chart-container" style="padding-top: 15px; font-family: Staatliches;">
                <canvas id="line-chart"></canvas>
            </div>
            <p style="text-align: justify; line-height: 1.7; padding-top: 25px; padding-bottom: 20px;">
                To fully appreciate the value of xG, we should consider a hypothetical
                scenario. Let's assume that {{ hteam }} decides to adopt a "shoot on sight"
                policy against {{ ateam }}. The coaching staff strongly encourage players to take shots
                from all angles and distances without considering the potential for better
                scoring opportunities. While this approach may inspire some spectators,
                the xG values associated to each of these shots are likely to be low.
                Conversely, let's assume that {{ ateam }} takes a more strategic approach,
                focusing on creating high-quality scoring chances rather than opting to
                shoot from any given position on the pitch. While {{hteam}} are likely
                to accumulate a much higher number of shots and shots on target,
                {{ateam}}'s ability to generate higher xG suggests a greater likelihood
                of actually scoring. This contrast is significant when we consider how
                analysts, fans, and pundits typically interpret these metrics to gauge
                the dominance of one team over another.
            </p>
            <hr style="margin-bottom: 80px">
            <h1 style="padding-bottom: 15px; font-size: 50px; font-family: Staatliches;
            font-weight: 300;">Expected Threat (xT)</h1>
            <p style="text-align: justify; line-height: 1.7; padding-top: 18px; padding-bottom: 18px">
            Having discussed xG and analyzed its application in deriving insights, a
                natural evolution in the analytical framework would involve considering
                all of the events that precede reaching these goal-scoring areas; passes,
                dribbles, blocks and interceptions. How do we assign value to these
                actions in manner that contributes towards our understanding of how
                one team increases the probability of scoring against the opposition?
                This is precisely where we start to inspect metrics that seek to determine
                <em>On-Ball Value</em> (OBV). The first OBV metric that we shall
                explore is Karun Singh's concept of <b><a href="https://karun.in/blog/expected-threat.html"
                   style="text-decoration: underline; background-color: yellow;">
                Expected Threat (xT)</a></b>. By incorporating xT, we begin to extend
                our assessment beyond goal-scoring probabilities and shift our focus
                towards evaluating the various phases of play that eventually lead to
                scoring opportunities. Traditionally, analyzing the progressive build-up
                of a team relied on metrics like completed carries or passes, which
                aimed to measure the effectiveness of advancing the ball into key areas
                of the pitch, such as the attacking final third and the attacking penalty
                box. The underlying assumption here is straightforward: the closer the
                attacking team gets to the defending team's goal, the higher the likelihood
                of scoring. This assumption is undoubtedly difficult to dispute, but as an
                analytical conclusion, it offers limited insights when attempting to provide
                a more comprehensive assessment of a team's build-up play as well as
                players capacity to generate <em>Threat</em> against the opposition.</p>
            <h2 style="padding-top: 22px; padding-bottom: 12px">How can we interpret xT?</h2>
            <p style="text-align: justify; line-height: 1.7; padding-bottom: 40px">
                You might begin to ask, how is xT formally defined? So, xT is calculated
                by quantifying the shift in scoring probability when one team manages
                to transition possession from one location on the pitch to another.
                Singh constructs a theoretical framework based on a possession-based
                Markov Model (Initially introduced by Sarah Rudd; 2010) in order to
                assign estimated values across every point on the pitch that reflects the
                probability of having the ball at that point will lead to a goal. A grid
                representation of the pitch is used here to visually display the transition
                matrix, which calculates the xT generated based on the movements of
                carries and passes between each of the different zones. The probabilities
                generated in each zone of the Markov Model will depend on the specific
                data chosen for training. The selection of data plays a pivotal role in
                determining the transition probabilities between zones because each
                team generates different levels of threat from various areas on the pitch,
                influenced by the unique playing style of each team.
            </p>
            <div style="display: flex; justify-content: center;">
                <img src="/static/xt.png" style="width: 60%; margin: 0 auto;">
            </div>
            <p style="text-align: center; font-style: italic; font-size: 11px;">Image Source: [The Athletic]</p>
            <h2 style="padding-top: 22px; font-size: 24px; text-align: center; font-family: Staatliches;">xThreat Map</h2>
            <div style="display: flex; gap: 5px; font-size: 17px; font-family: Staatliches; font-weight: bold; align-items: center; justify-content: center;">
                <script src="https://d3js.org/d3.v7.min.js"></script>
                <label for="xteams-select">Team:</label>
                <select id="xteams-select">
                    <option value="">All Teams</option>
                </select>
                <label for="xactions-select">Action:</label>
                <select id="xactions-select">
                    <option value="">All Actions</option>
                </select>
                <label for="xplayers-select">Player:</label>
                <select id="xplayers-select">
                    <option value="">All Players</option>
                </select>
            </div>
            <div class="grid" style="margin: 0 auto; display: flex; justify-content: center;">
                 <img src="/static/pitch.png" style="margin: 0 auto;" alt="xT Image">
            </div>
        </div>
    </div>
    <div class="progress-bar"></div>
    <script src="https://ajax.googleapis.com/ajax/libs/jquery/3.5.1/jquery.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/Chart.js/2.9.4/Chart.min.js"></script>
    <script>
// DECLARE DATA COLLECTION VARIABLES
var requestCounter = 0;
var matchstats = JSON.parse('{{ matchstats | tojson }}');
var xgmap = JSON.parse('{{ xgmap | tojson }}');
var xtmap = JSON.parse('{{ xtmap | tojson }}');
var xgtimeline = JSON.parse('{{ xgtimeline | tojson }}');
var currentRequest = null;
var filteredXGMap = [];
var filteredXTMap = [];
var filteredXGTimeline = [];
var xtdata = [];

// DECLARE DIAGRAM VARIABLES
var imgWidth = 600;
var imgHeight = 450;
var svg = d3.select('#plot-container')
  .append('svg')
  .attr('width', imgWidth)
  .attr('height', imgHeight);
console.log("SVG container created");
var pitchImage = svg.append('image')
  .attr('href', '/static/xg_pitch.png')
  .attr('width', imgWidth)
  .attr('height', imgHeight);
  console.log("Pitch image loaded");

// DECLARE SLIDER
var slider = document.getElementById("minute-slider");
noUiSlider.create(slider, {
  start: [{{ min_playedmins }}, {{ max_playedmins }}],
  range: {
    min: {{ min_playedmins }},
    max: {{ max_playedmins }}
  },
  step: 1,
  format: {
    to: function (value) {
      return Math.round(value);
    },
    from: function (value) {
      return Number(value);
    }
  },
  connect: [false, true, false]
});
console.log("Slider created");
var connectBar = slider.querySelectorAll(".noUi-connects .noUi-connect");
connectBar[0].style.background = "#00ff97";
console.log("Slider background color set");

// DECLARE SLIDER HANDLE VARIABLES
var handleIDs = ["handle-label-0", "handle-label-1"];
var handleValues = handleIDs.map(function (id) {
  return document.getElementById(id);
});
console.log("Handle elements obtained");

slider.noUiSlider.on("update", function (values) {
  var minuteValues = values.map(function (value) {
    return Math.round(value);
  });
  var filteredEvents = matchstats.filter(function (event) {
    return event.match_minute >= minuteValues[0] && event.match_minute <= minuteValues[1];
  });

  var handleValueText = "";
  if (filteredEvents.length > 0) {
    var timelineStart = filteredEvents[0].timeline;
    var timelineEnd = filteredEvents[filteredEvents.length - 1].timeline;
    handleValueText = timelineStart + " - " + timelineEnd;
  }
  handleValues[1].innerHTML = handleValueText;
  filterEvents(minuteValues[0], minuteValues[1]);
});


// DECLARE LINE CHART VARIABLES
var lineChartContainer = document.getElementById('line-chart-container');
var lineChartCanvas = document.getElementById('line-chart');
var lineChart;
lineChartContainer.style.width = '550px';
lineChartContainer.style.height = '500px';
lineChartContainer.style.margin = 'auto';
lineChartContainer.style.display = 'block';
lineChartCanvas.style.width = '100%';
lineChartCanvas.style.height = '100%';


// CREATE LINE CHART INSTANCE
function createLineChart() {
  var ctx = lineChartCanvas.getContext('2d');
  lineChart = new Chart(ctx, {
    type: 'line',
    data: {
      labels: [],
      datasets: [
        {
          label: 'Goals Scored By {{ hteam }}',
          data: [],
          borderColor: 'red',
          borderWidth: 1.5,
          pointRadius: 0,
          fill: '+1',
          backgroundColor: 'rgba(255, 0, 0, 0.2)',
        },
        {
          label: 'Goals Scored By {{ ateam }}',
          data: [],
          borderColor: 'blue',
          borderWidth: 1.5,
          pointRadius: 0,
          fill: false,
        }
      ]
    },
    options: {
      responsive: true,
      title: {
        display: true,
        text: 'xG Timeline',
        fontSize: 24,
        fontFamily: 'Staatliches',
        fontColor: 'Black'
      },
      scales: {
        xAxes: [{
          display: true,
          scaleLabel: {
            display: true,
            labelString: 'Minutes Played',
            fontSize: 19,
            fontFamily: 'Staatliches',
            fontColor: 'Black'
          },
          gridLines: {
            display: false
          }
        }],
        yAxes: [{
          display: true,
          scaleLabel: {
            display: true,
            labelString: 'Cumulative xG',
            fontSize: 19,
            fontFamily: 'Staatliches',
            fontColor: 'Black'
          },
          gridLines: {
            display: true
          }
        }]
      },
      legend: {
        display: true,
        labels: {
          usePointStyle: true
        },
      },
      elements: {
        line: {
          tension: 0,
        }
      }
    }
  });
}


// DECLARE STATS VARIABLES & COLOURED BACKGROUND
function updateStatBoxBackgrounds() {
  var hteamScore = parseFloat($("#hteam-score").html());
  var ateamScore = parseFloat($("#ateam-score").html());
  var hteamXG = parseFloat($("#hteam-xg").html());
  var ateamXG = parseFloat($("#ateam-xg").html());
  var hteamOpXG = parseFloat($("#hteam-opxg").html());
  var ateamOpXG = parseFloat($("#ateam-opxg").html());
  var hteamSpXG = parseFloat($("#hteam-spxg").html());
  var ateamSpXG = parseFloat($("#ateam-spxg").html());
  var hteamShot = parseInt($("#hteam-shot").html());
  var ateamShot = parseInt($("#ateam-shot").html());
  var hteamShotOnTarget = parseInt($("#hteam-shotot").html());
  var ateamShotOnTarget = parseInt($("#ateam-shotot").html());
  var hteamRedCard = parseInt($("#hteam-redcard").html());
  var ateamRedCard = parseInt($("#ateam-redcard").html());
  var hteamPossession = parseFloat($("#hteam-poss").html());
  var ateamPossession = parseFloat($("#ateam-poss").html());
  var hteamPossPercentage = (hteamPossession / (hteamPossession + ateamPossession)) * 100;
  var ateamPossPercentage = (ateamPossession / (hteamPossession + ateamPossession)) * 100;
  var hteamPasses = parseInt($("#hteam-pass").html());
  var ateamPasses = parseInt($("#ateam-pass").html());
  var hteamAccPasses = parseFloat($("#hteam-accpass").html());
  var ateamAccPasses = parseFloat($("#ateam-accpass").html());
  var hteamFTEntries = parseInt($("#hteam-ftentries").html());
  var ateamFTEntries = parseInt($("#ateam-ftentries").html());
  var hteamPBEntries = parseInt($("#hteam-pbentries").html());
  var ateamPBEntries = parseInt($("#ateam-pbentries").html());
  var hteamPossPercentage = (hteamPossession / (hteamPossession + ateamPossession)) * 100;
  var ateamPossPercentage = (ateamPossession / (hteamPossession + ateamPossession)) * 100;
  var hteamPassPercentage = (hteamAccPasses / hteamPasses) * 100;
  var ateamPassPercentage = (ateamAccPasses / ateamPasses) * 100;

  $("#hteam-xg").toggleClass("higher", hteamXG > ateamXG).toggleClass("lower", hteamXG < ateamXG);
  $("#ateam-xg").toggleClass("higher", ateamXG > hteamXG).toggleClass("lower", ateamXG < hteamXG);
  $("#hteam-opxg").toggleClass("higher", hteamOpXG > ateamOpXG).toggleClass("lower", hteamOpXG < ateamOpXG);
  $("#ateam-opxg").toggleClass("higher", ateamOpXG > hteamOpXG).toggleClass("lower", ateamOpXG < hteamOpXG);
  $("#hteam-spxg").toggleClass("higher", hteamSpXG > ateamSpXG).toggleClass("lower", hteamSpXG < ateamSpXG);
  $("#ateam-spxg").toggleClass("higher", ateamSpXG > hteamSpXG).toggleClass("lower", ateamSpXG < hteamSpXG);
  $("#hteam-shot").toggleClass("higher", hteamShot > ateamShot).toggleClass("lower", hteamShot < ateamShot);
  $("#ateam-shot").toggleClass("higher", ateamShot > hteamShot).toggleClass("lower", ateamShot < hteamShot);
  $("#hteam-shotot").toggleClass("higher", hteamShotOnTarget > ateamShotOnTarget).toggleClass("lower", hteamShotOnTarget < ateamShotOnTarget);
  $("#ateam-shotot").toggleClass("higher", ateamShotOnTarget > hteamShotOnTarget).toggleClass("lower", ateamShotOnTarget < hteamShotOnTarget);
  $("#hteam-redcard").toggleClass("higher", hteamRedCard > ateamRedCard).toggleClass("lower", hteamRedCard < ateamRedCard);
  $("#ateam-redcard").toggleClass("higher", ateamRedCard > hteamRedCard).toggleClass("lower", ateamRedCard < hteamRedCard);
  $("#hteam-poss").toggleClass("higher", hteamPossession > ateamPossession).toggleClass("lower", hteamPossession < ateamPossession);
  $("#ateam-poss").toggleClass("higher", ateamPossession > hteamPossession).toggleClass("lower", ateamPossession < hteamPossession);
  $("#hteam-poss").html(hteamPossPercentage.toFixed(2) + "%");
  $("#ateam-poss").html(ateamPossPercentage.toFixed(2) + "%");
  $("#hteam-pass").toggleClass("higher", hteamPasses > ateamPasses).toggleClass("lower", hteamPasses < ateamPasses);
  $("#ateam-pass").toggleClass("higher", ateamPasses > hteamPasses).toggleClass("lower", ateamPasses < hteamPasses);
  $("#hteam-accpass").toggleClass("higher", hteamAccPasses > ateamAccPasses).toggleClass("lower", hteamAccPasses < ateamAccPasses);
  $("#ateam-accpass").toggleClass("higher", ateamAccPasses > hteamAccPasses).toggleClass("lower", ateamAccPasses < hteamAccPasses);
  $("#hteam-accpass").html(hteamPassPercentage.toFixed(2) + "%");
  $("#ateam-accpass").html(ateamPassPercentage.toFixed(2) + "%");
  $("#hteam-ftentries").toggleClass("higher", hteamFTEntries > ateamFTEntries).toggleClass("lower", hteamFTEntries < ateamFTEntries);
  $("#ateam-ftentries").toggleClass("higher", ateamFTEntries > hteamFTEntries).toggleClass("lower", ateamFTEntries < hteamFTEntries);
  $("#hteam-pbentries").toggleClass("higher", hteamPBEntries > ateamPBEntries).toggleClass("lower", hteamPBEntries < ateamPBEntries);
  $("#ateam-pbentries").toggleClass("higher", ateamPBEntries > hteamPBEntries).toggleClass("lower", ateamPBEntries < hteamPBEntries);
}

// FILTER DATA TABLES ACCORDING TO THE SLIDER POSITION
function filterEvents(minute_start, minute_end) {
  requestCounter++;
  var requestId = requestCounter;
  // Abort the previous AJAX request if it's still in progress
  if (currentRequest && currentRequest.readyState !== 4) {
    currentRequest.abort();
  }
  currentRequest = $.ajax({
    url: "/getFilteredEvents",
    type: "POST",
    contentType: "application/json",
    data: JSON.stringify({
      minute_start: minute_start,
      minute_end: minute_end,
      matchstats: matchstats,
      xgmap: xgmap,
      xgtimeline: xgtimeline,
      xtmap: xtmap,
    }),
    success: function (response) {
      if (requestId === requestCounter) {
        filteredXGTimeline = response.filtered_xgtimeline;
        var xgdata = filteredXGTimeline;
        filteredXGMap = response.filtered_xgmap;
        var data = filteredXGMap;
        filteredXTMap = response.filtered_xtmap;
        var xtdata = filteredXTMap;
        var hteamScore = response.hteam_score;
        var ateamScore = response.ateam_score;
        var hteamScorers = response.hteam_scorers;
        var ateamScorers = response.ateam_scorers;
        var hteamXG = response.hteam_xg;
        var ateamXG = response.ateam_xg;
        var hteamOpXG = response.hteam_opxg;
        var ateamOpXG = response.ateam_opxg;
        var hteamSpXG = response.hteam_spxg;
        var ateamSpXG = response.ateam_spxg;
        var hteamShot = response.hteam_shot;
        var ateamShot = response.ateam_shot;
        var hteamShotOnTarget = response.hteam_shotot;
        var ateamShotOnTarget = response.ateam_shotot;
        var hteamRedCard = response.hteam_redcard;
        var ateamRedCard = response.ateam_redcard;
        var hteamPossession = response.hteam_poss;
        var ateamPossession = response.ateam_poss;
        var hteamPossPercentage = parseFloat((hteamPossession / (ateamPossession + hteamPossession) * 100).toFixed(1));
        var ateamPossPercentage = parseFloat((ateamPossession / (ateamPossession + hteamPossession) * 100).toFixed(1));
        var hteamPasses = response.hteam_pass;
        var ateamPasses = response.ateam_pass;
        var hteamAccPasses = response.hteam_accpass;
        var ateamAccPasses = response.ateam_accpass;
        var hteamFTEntries = response.hteam_ftentries;
        var ateamFTEntries = response.ateam_ftentries;
        var hteamPBEntries = response.hteam_pbentries;
        var ateamPBEntries = response.ateam_pbentries;

        // Update the DOM elements with the new values
        $("#hteam-score").html(hteamScore);
        $("#ateam-score").html(ateamScore);
        $("#hteam-scorers").html(hteamScorers);
        $("#ateam-scorers").html(ateamScorers);
        $("#hteam-xg").html(hteamXG);
        $("#ateam-xg").html(ateamXG);
        $("#hteam-opxg").html(hteamOpXG);
        $("#ateam-opxg").html(ateamOpXG);
        $("#hteam-spxg").html(hteamSpXG);
        $("#ateam-spxg").html(ateamSpXG);
        $("#hteam-shot").html(hteamShot);
        $("#ateam-shot").html(ateamShot);
        $("#hteam-shotot").html(hteamShotOnTarget);
        $("#ateam-shotot").html(ateamShotOnTarget);
        $("#hteam-redcard").html(hteamRedCard);
        $("#ateam-redcard").html(ateamRedCard);
        $("#hteam-poss").html(hteamPossession);
        $("#ateam-poss").html(ateamPossession);
        $("#hteam-poss").html(parseFloat(hteamPossPercentage).toFixed(1) + "%");
        $("#ateam-poss").html(parseFloat(ateamPossPercentage).toFixed(1) + "%");
        $("#hteam-pass").html(hteamPasses);
        $("#ateam-pass").html(ateamPasses);
        $("#hteam-accpass").html(hteamAccPasses);
        $("#ateam-accpass").html(ateamAccPasses);
        $("#hteam-ftentries").html(hteamFTEntries);
        $("#ateam-ftentries").html(ateamFTEntries);
        $("#hteam-pbentries").html(hteamPBEntries);
        $("#ateam-pbentries").html(ateamPBEntries);

        // Update the background colors of stat boxes
        updateStatBoxBackgrounds();
        var teams = [...new Set(data.map(function (d) {
          return d.team;
        }))];
        var shotTypes = [...new Set(data.map(function (d) {
          return d.shotType;
        }))];
        var players = [...new Set(data.map(function (d) {
          return d.player;
        }))];
        // Reset dropdown options
        resetDropdownOptions('team-select');
        resetDropdownOptions('shot-type-select');
        resetDropdownOptions('player-select');
        // Update dropdown options
        updateDropdownOptions('team-select', ['All'].concat(teams));
        updateDropdownOptions('shot-type-select', ['All'].concat(shotTypes));
        updateDropdownOptions('player-select', ['All'].concat(players));
        // Set the initial selected option to "All"
        document.getElementById('team-select').value = 'All';
        document.getElementById('shot-type-select').value = 'All';
        document.getElementById('player-select').value = 'All';
        // Update the xG shot map with filtered data
        updatePlot();
        updateLineChartData();

        var xteams = [...new Set(xtdata.map(function (d) {
          return d.team_name;
        }))];
        var xactions = [...new Set(xtdata.map(function (d) {
          return d.type;
        }))];
        var xplayers = [...new Set(xtdata.map(function (d) {
          return d.player_name;
        }))];
        // Reset dropdown options
        resetDropdownOptions('xteams-select');
        resetDropdownOptions('xactions-select');
        resetDropdownOptions('xplayers-select');
        // Update dropdown options
        updateDropdownOptions('xteams-select', ['All'].concat(xteams));
        updateDropdownOptions('xactions-select', ['All'].concat(xactions));
        updateDropdownOptions('xplayers-select', ['All'].concat(xplayers));
        // Set the initial selected option to "All"
        document.getElementById('xteams-select').value = 'All';
        document.getElementById('xactions-select').value = 'All';
        document.getElementById('xplayers-select').value = 'All';
      }
    }
  });
}
// INITIALIZE LINE CHART
createLineChart();
updateLineChartData();


function updateLineChartData() {
  var matchMinutes = filteredXGTimeline.map(function(data) {
    return data.timeline;
  });
  var hteamXGValues = filteredXGTimeline.map(function(data) {
    return data.CumHTxG;
  });
  var ateamXGValues = filteredXGTimeline.map(function(data) {
    return data.CumATxG;
  });
  var hteamGoals = filteredXGTimeline.map(function(data) {
    return data.HTGoal;
  });
  var ateamGoals = filteredXGTimeline.map(function(data) {
    return data.ATGoal;
  });
  lineChart.data.labels = matchMinutes;
  lineChart.data.datasets[0].data = hteamXGValues;
  lineChart.data.datasets[1].data = ateamXGValues;

  var hteamDataset = lineChart.data.datasets[0];
  hteamDataset.pointRadius = hteamGoals.map(function(goal) {
    return (goal === 0) ? 0 : 8; // Set point radius to 0 for HTGoal = 0, otherwise 5
  });
  hteamDataset.pointBorderColor = hteamGoals.map(function(goal) {
    return (goal === 1) ? 'white' : hteamDataset.borderColor; // Set point border color to white for HTGoal = 1, otherwise use dataset's border color
  });
  hteamDataset.pointBorderWidth = hteamGoals.map(function(goal) {
    return (goal === 1) ? 1.2 : 0; // Set point border width to 1 for HTGoal = 1, otherwise 0
  });
  hteamDataset.pointBackgroundColor = hteamDataset.borderColor;

  var ateamDataset = lineChart.data.datasets[1];
  ateamDataset.pointRadius = ateamGoals.map(function(goal) {
    return (goal === 0) ? 0 : 8; // Set point radius to 0 for ATGoal = 0, otherwise 5
  });
  ateamDataset.pointBorderColor = ateamGoals.map(function(goal) {
    return (goal === 1) ? 'white' : ateamDataset.borderColor; // Set point border color to white for ATGoal = 1, otherwise use dataset's border color
  });
  ateamDataset.pointBorderWidth = ateamGoals.map(function(goal) {
    return (goal === 1) ? 1.2 : 0; // Set point border width to 1 for ATGoal = 1, otherwise 0
  });
  ateamDataset.pointBackgroundColor = ateamDataset.borderColor
  lineChart.update();
}


window.onload = function() {
  // DECLARE GRID SECTIONS
  var gridSections = [
    { x: 1.07, y: 1.22, width: 2.71, height: 2.16, zone: 1 },  // Z1
    { x: 3.78, y: 1.22, width: 3.12, height: 2.16, zone: 2},  // Z2
    { x: 6.9, y: 1.22, width: 3.12, height: 2.16, zone: 3 },  // Z3
    { x: 10.02, y: 1.22, width: 3.12, height: 2.16, zone: 4 }, // Z4
    { x: 13.14, y: 1.22, width: 3.12, height: 2.16, zone: 5 }, // Z5
    { x: 16.26, y: 1.22, width: 2.71, height: 2.16, zone: 6 }, // Z6
    { x: 3.78, y: 3.38, width: 6.24, height: 1.43, zone: 7 }, // Z7
    { x: 3.78, y: 4.81, width: 6.24, height: 2.39, zone: 8 }, // Z8
    { x: 3.78, y: 7.2, width: 6.24, height: 1.43, zone: 9 }, // Z9
    { x: 10.02, y: 3.38, width: 6.24, height: 1.43, zone: 10 }, // Z10
    { x: 10.02, y: 4.81, width: 6.24, height: 2.39, zone: 11 }, // Z11
    { x: 10.02, y: 7.2, width: 6.24, height: 1.43, zone: 12 }, // Z12
    { x: 1.07, y: 3.38, width: 2.71, height: 5.25, zone: 13 }, // Z13
    { x: 1.07, y: 8.63, width: 2.71, height: 2.16, zone: 14 }, // Z14
    { x: 3.78, y: 8.63, width: 3.12, height: 2.16, zone: 15 }, // Z15
    { x: 6.9, y: 8.63, width: 3.12, height: 2.16, zone: 16 }, // Z16
    { x: 10.02, y: 8.63, width: 3.12, height: 2.16, zone: 17 }, // Z17
    { x: 13.14, y: 8.63, width: 3.12, height: 2.16, zone: 18 }, // Z18
    { x: 16.26, y: 8.63, width: 2.71, height: 2.16, zone: 19 }, // Z19
    { x: 16.26, y: 3.38, width: 2.71, height: 5.25, zone: 20 }, // Z20
  ];

  // Get references to the pitch image and the grid container
  const pitch = document.querySelector("img");
  const pitchWidth = pitch.offsetWidth * 12;
  const pitchHeight = pitch.offsetHeight * 9;
  const grid = document.querySelector(".grid");
  grid.style.width = pitchWidth + "px";
  grid.style.height = pitchHeight + "px";

  // Create an array to store the sum values for each grid section
  const sumValues = gridSections.map(() => ({ element: null, sum: 0 }));

// Iterate through the grid sections data and create grid boxes with event listeners
for (let i = 0; i < gridSections.length; i++) {
  const section = gridSections[i];

  // Create a div for the grid box
  const gridBox = document.createElement("div");
  gridBox.style.position = "absolute";
  gridBox.style.left = section.x * (pitchWidth / 20) + "px";
  gridBox.style.top = section.y * (pitchHeight / 12) + "px";
  gridBox.style.width = section.width * (pitchWidth / 20) + "px";
  gridBox.style.height = section.height * (pitchHeight / 12) + "px";
  gridBox.style.zIndex = "2";
  gridBox.style.background = "rgba(0, 0, 0, 0)";

  // Create a div to display the sum value for the hovered grid section
  const sumElement = document.createElement("div");
  sumElement.classList.add("grid-sum");
  sumElement.style.display = "none";
  gridBox.appendChild(sumElement);
  // Add the grid box to the grid container
  grid.appendChild(gridBox);

  // Assign the sum element to the corresponding entry in the sumValues array
  sumValues[i].element = sumElement;

  // Add event listeners for mouseover and mouseout events on the grid box
  gridBox.addEventListener("mouseover", createMouseOverHandler(i));
  gridBox.addEventListener("mouseout", createMouseOutHandler());
}

  // Function to recalculate and display xT sum values for all zones
  function calculateAndDisplayAllSums() {
    // Calculate the sums for all zones
    calculateSumsForAllZones();

    // Display the sums for all zones
    updateSumsForAllZones();
  }

  // Call the function to calculate and display sums for all zones when the page loads
  calculateAndDisplayAllSums();

  function createMouseOverHandler(index) {
    return function () {
      // Remove borders from all grid sections
      const gridBoxes = document.querySelectorAll(".grid div");
      for (let box of gridBoxes) {
        box.style.border = "none";
      }

      // Get the sum element for the current grid section
      const sumElement = sumValues[index].element;

      // Get the zone value for the current grid section
      const zone = gridSections[index].zone;

      // Hide all sum elements except for the current grid section
      for (let i = 0; i < sumValues.length; i++) {
        const otherSumElement = sumValues[i].element;
        if (i !== index) {
          otherSumElement.style.display = "none";
        }
      }

      // Get the selected values from the dropdowns
      const selectedTeam = document.getElementById('xteams-select').value;
      const selectedAction = document.getElementById('xactions-select').value;
      const selectedPlayer = document.getElementById('xplayers-select').value;

      // Filter the filteredXTMap data based on the zone and the selected values
      let filteredRows = filteredXTMap;
      filteredRows = filteredRows.filter(function (row) {
        return row.start_zone === zone;
      });
      if (selectedTeam !== 'All') {
        filteredRows = filteredRows.filter(function (row) {
          return row.team_name === selectedTeam;
        });
      }
      if (selectedAction !== 'All') {
        filteredRows = filteredRows.filter(function (row) {
          return row.type === selectedAction;
        });
      }
      if (selectedPlayer !== 'All') {
        filteredRows = filteredRows.filter(function (row) {
          return row.player_name === selectedPlayer;
        });
      }

      // Sum the xT values for the filtered rows
      const sum = filteredRows.reduce((acc, row) => acc + row.xT, 0);

      // Display the sum inside the hovered grid section
      sumElement.innerText = `Sum: ${sum.toFixed(2)}`; // Display the sum with 2 decimal places
      sumElement.style.display = "block";
      sumElement.style.left = this.style.left;
      sumElement.style.top = this.style.top;
      this.style.background = "rgba(0, 0, 0, 0.5)";
      this.style.border = "1px solid black"; // Add black border on hover
    };
  }

  // Function to handle mouseout event on grid sections
  function createMouseOutHandler() {
    return function() {
      this.style.background = "rgba(0, 0, 0, 0)";
      this.style.border = "none"; // Remove border on mouseout

      // Hide all sum elements
      const sumElements = document.querySelectorAll(".grid-sum");
      for (let element of sumElements) {
        element.style.display = "none";
      }

      // Calculate the sums for all zones
      calculateSumsForAllZones();

      // Display the sums for all zones
      updateSumsForAllZones();

      // Calculate and display the sums for all zones
      calculateAndDisplayAllSums();
    };
  }

  // Function to calculate the sums for all zones
  function calculateSumsForAllZones() {
    // Get the selected values from the dropdowns
    const selectedTeam = document.getElementById('xteams-select').value;
    const selectedAction = document.getElementById('xactions-select').value;
    const selectedPlayer = document.getElementById('xplayers-select').value;

    // Calculate the sum for each zone
    for (let i = 0; i < gridSections.length; i++) {
      const zone = gridSections[i].zone;

      // Filter the filteredXTMap data based on the zone and the selected values
      let filteredRows = filteredXTMap;
      filteredRows = filteredRows.filter(function(row) {
        return row.start_zone === zone;
      });
      if (selectedTeam !== 'All') {
        filteredRows = filteredRows.filter(function(row) {
          return row.team_name === selectedTeam;
        });
      }
      if (selectedAction !== 'All') {
        filteredRows = filteredRows.filter(function(row) {
          return row.type === selectedAction;
        });
      }
      if (selectedPlayer !== 'All') {
        filteredRows = filteredRows.filter(function(row) {
          return row.player_name === selectedPlayer;
        });
      }

      // Sum the xT values for the filtered rows
      const sum = filteredRows.reduce((acc, row) => acc + row.xT, 0);

      // Update the sum for the zone in the sumValues array
      sumValues[i].sum = sum;
    }
  }


  // Function to update the sums for all zones in the DOM
  function updateSumsForAllZones() {
    for (let i = 0; i < sumValues.length; i++) {
      const sumValue = sumValues[i].sum;
      const zoneElement = sumValues[i].element;
      zoneElement.innerText = `Sum: ${sumValue.toFixed(2)}`;
      zoneElement.style.display = "block";
      zoneElement.style.left = gridSections[i].x * (pitchWidth / 20) + "px";
      zoneElement.style.top = gridSections[i].y * (pitchHeight / 12) + "px";
    }
  }

  // Function to update dropdown options
  function updateDropdownOptions(selectId, options, selectedValue) {
    var selectElement = document.getElementById(selectId);
    selectElement.innerHTML = '';
    for (var i = 0; i < options.length; i++) {
      var option = document.createElement('option');
      option.value = options[i];
      option.text = options[i];
      selectElement.appendChild(option);
    }

    // Set the selected value for the dropdown
    selectElement.value = selectedValue;
  }

  // Function to update dropdowns and recreate grid based on selected values
  function updateDropdowns() {
    const selectedTeam = document.getElementById('xteams-select').value;
    const selectedAction = document.getElementById('xactions-select').value;
    const selectedPlayer = document.getElementById('xplayers-select').value;

    // Filter the options for each dropdown based on selected values
    const filteredXTMapWithSelection = filteredXTMap.filter(function(d) {
      return (selectedTeam === 'All' || d.team_name === selectedTeam) &&
        (selectedAction === 'All' || d.type === selectedAction);
    });
    const updatedTeams = ['All'].concat([...new Set(filteredXTMap.map(function(d) {
      return d.team_name;
    }))]);
    const updatedActions = ['All'].concat([...new Set(filteredXTMap.map(function(d) {
      return d.type;
    }))]);
    const updatedPlayers = ['All'].concat([...new Set(filteredXTMapWithSelection.map(function(d) {
      return d.player_name;
    }))]);

    updateDropdownOptions('xteams-select', updatedTeams, selectedTeam);
    updateDropdownOptions('xactions-select', updatedActions, selectedAction);
    updateDropdownOptions('xplayers-select', updatedPlayers, selectedPlayer);

    // Re-filter the filteredXTMap data based on the selected options
    filterXTMap(selectedTeam, selectedAction, selectedPlayer);

    // Calculate the sums for all zones
    calculateSumsForAllZones();

    // Display the sums for all zones
    updateSumsForAllZones();
    
    // Calculate and display the sums for all zones
    calculateAndDisplayAllSums();
  }

    // Function to calculate and display sums for all zones when the filteredXTMap data is ready
    function calculateAndDisplaySumsWhenReady() {
    // Check if the filteredXTMap data is ready
    if (filteredXTMap) {
      // Call the function to calculate and display sums for all zones
      calculateAndDisplayAllSums();
    } else {
      // If the data is not ready, wait for a short duration and then check again
      setTimeout(calculateAndDisplaySumsWhenReady, 50);
    }
  }

  // Add event listeners to the dropdowns
  document.getElementById('xteams-select').addEventListener('change', updateDropdowns);
  document.getElementById('xactions-select').addEventListener('change', updateDropdowns);
  document.getElementById('xplayers-select').addEventListener('change', updateDropdowns);

  // Initial setup of dropdown options
  updateDropdowns();

  // Call the function to calculate and display sums for all zones when the page loads
  calculateSumsForAllZones();

  // Display the sums for all zones
  updateSumsForAllZones();

  // Call the function to calculate and display sums for all zones when the page loads
  calculateAndDisplaySumsWhenReady();
};

// Test

// DECLARE TEAM LEGEND VARIABLES
var teamLegendX = 65; // X position of the team legend box
var teamLegendY = 260; // Y position of the team legend box
var teamLegendWidth = 75; // Width of the team legend box
var teamLegendHeight = 25; // Height of the team legend box
var teamLegendLabelX = 13; // Fixed x-coordinate for team legend labels

// DECLARE SHOT TYPE LEGEND VARIABLES
var shotTypeLegendX = 42; // X position of the shot type legend box
var shotTypeLegendY = 265; // Y position of the shot type legend box
var shotTypeLegendWidth = 140; // Width of the shot type legend box
var shotTypeLegendHeight = 200; // Height of the shot type legend box
var shotTypeLegendItemHeight = 18; // Height of each shot type legend item

//  CONSTRUCT XG LEGEND VARIABLES
var xGLegendX = 425; // X position of the xG legend box
var xGLegendY = 360; // Y position of the xG legend box
var xGLegendWidth = 120; // Width of the xG legend box
var xGLegendHeight = 20; // Height of the xG legend box
var visualLegendX = 425; // X position of the visual legend box
var visualLegendY = xGLegendY + xGLegendHeight + 3; // Y position of the visual legend box
var visualLegendWidth = 120; // Width of the visual legend box
var visualLegendHeight = 20; // Height of the visual legend box

//  CONSTRUCT XG SHOT MAP PLOT
function updatePlot() {
  var selectedTeam = document.getElementById('team-select').value;
  var selectedShotType = document.getElementById('shot-type-select').value;
  var selectedPlayer = document.getElementById('player-select').value;
  var filteredData = filteredXGMap;

  if (selectedTeam) {
    filteredData = filteredData.filter(function(d) {
      return d.team === selectedTeam;
    });
  }
  if (selectedShotType) {
    filteredData = filteredData.filter(function(d) {
      return d.shotType === selectedShotType;
    });
  }
  if (selectedPlayer) {
    filteredData = filteredData.filter(function(d) {
      return d.player === selectedPlayer;
    });
  }

  var filteredData = filteredXGMap.slice();
  if (selectedTeam !== 'All') {
    filteredData = filteredData.filter(function(d) {
      return d.team === selectedTeam;
    });
  }
  if (selectedShotType !== 'All') {
    filteredData = filteredData.filter(function(d) {
      return d.shotType === selectedShotType;
    });
  }
  if (selectedPlayer !== 'All') {
    filteredData = filteredData.filter(function(d) {
      return d.player === selectedPlayer;
    });
  }

  var xGColorScale = d3.scaleLinear()
    .domain([0, 1])
    .range(['#a6a6a6', '#333333']);

  // Clear the SVG container
  svg.selectAll(".shape-plot").remove();
  svg.selectAll(".legend").remove();

  var teamColorScale = d3.scaleOrdinal()
    .domain([...new Set(filteredData.map(function(d) { return d.team; }))])
    .range(['red', 'blue']);

  // Create a symbol generator
  var symbolGenerator = d3.symbol().size(225);

  // Create a set of unique shot types
  var shotTypes = [...new Set(filteredData.map(function(d) {
    return d.shotType;
  }))];

  // Create an ordinal scale for shot types and assign symbols
  var shotTypeSymbolScale = d3.scaleOrdinal()
    .domain(shotTypes)
    .range([
      d3.symbolCircle,
      d3.symbolSquare,
      d3.symbolTriangle,
      d3.symbolCross,
      d3.symbolDiamond,
      d3.symbolStar,
      d3.symbolWye
    ]);

  // Add shapes
  svg.selectAll('.shape-plot')
    .data(filteredData)
    .enter()
    .append('path')
    .attr('class', 'shape-plot')
    .attr('d', function(d) {
      symbolGenerator.type(shotTypeSymbolScale(d.shotType));
      return symbolGenerator();
    })
    .attr('transform', function(d) {
      var x = (d.x / 40) * imgWidth;
      var y = (d.y / 60) * imgHeight;
      return 'translate(' + x + ',' + y + ')';
    })
    .style('fill', function(d) {
      if (teamColorScale(d.team) === 'red') {
        // For red team, apply the gradient from light red to dark red based on xG
        return d3.interpolate('#ffcccc', '#ff0000')(d.xG);
      } else if (teamColorScale(d.team) === 'blue') {
        // For blue team, apply the gradient from light blue to dark blue based on xG
        return d3.interpolate('#ccddff', '#0000ff')(d.xG);
      } else {
        // For other teams, use black color
        return 'black';
      }
    })
    .style('opacity', 0.8)
    .style('stroke', 'black')
    .style('stroke-width', 0.2);

  // Create the team legend group element and set its position
  var teamLegendGroup = svg.append("g")
    .attr("class", "legend")
    .attr("transform", "translate(" + teamLegendX + "," + teamLegendY + ")");

  // Get unique team names
  var teamNames = [...new Set(filteredData.map(function(d) {
    return d.team;
  }))];

  // Create rectangles for each team in the legend
  var teamLegendRects = teamLegendGroup.selectAll(".team-legend-rect")
    .data(teamNames)
    .enter()
    .append("rect")
    .attr("x", teamLegendLabelX) // Fixed x-coordinate
    .attr("x", -7)
    .attr("y", function(d, i) {
      return i * 20;
    })
    .attr("width", 16)
    .attr("height", 16)
    .style("fill", function(d) {
      return teamColorScale(d);
    });

  // Add text labels to the team legend
  var teamLegendLabels = teamLegendGroup.selectAll(".team-legend-label")
    .data(teamNames)
    .enter()
    .append("text")
    .attr("class", "team-legend-label")
    .attr("x", teamLegendLabelX) // Fixed x-coordinate
    .attr("y", function(d, i) {
      return i * 20 + 13;   // Y Position
    })
    .text(function(d) {
      return d;
    })
    .style("font-size", "14px");

  // Calculate the total height of the shot type legend based on the number of items
  var shotTypeLegendTotalHeight = shotTypes.length * shotTypeLegendItemHeight;

  // Calculate the vertical offset to center the legend
  var shotTypeLegendOffsetY = (shotTypeLegendHeight - shotTypeLegendTotalHeight) / 2;

  // Create the shot type legend group element and set its position
  var shotTypeLegendGroup = svg.append("g")
    .attr("class", "legend")
    .attr("transform", "translate(" + shotTypeLegendX + "," + (shotTypeLegendY + shotTypeLegendOffsetY) + ")");

  // Create symbols for each shot type in the legend
  var shotTypeLegendSymbols = shotTypeLegendGroup.selectAll(".shot-type-legend-symbol")
    .data(shotTypes)
    .enter()
    .append("path")
    .attr("class", "shot-type-legend-symbol")
    .attr("d", function(d) {
      symbolGenerator.type(shotTypeSymbolScale(d)).size(60);
      return symbolGenerator();
    })
    .attr("transform", function(d, i) {
      return "translate(24," + (i * shotTypeLegendItemHeight) + ")";
    })
    .style("fill", "none")
    .style("stroke", "black")
    .style("stroke-width", 1);

  // Add text labels to the shot type legend
  shotTypeLegendGroup.selectAll(".shot-type-legend-label")
    .data(shotTypes)
    .enter()
    .append("text")
    .attr("class", "shot-type-legend-label")
    .attr("x", 35)
    .attr("y", function(d, i) {
      return i * shotTypeLegendItemHeight + 5;
    })
    .text(function(d) {
      return d;
    })
    .style("font-size", "14px");

  // Define the xG scale and color interpolation (white to red)
  var xGScale = d3.scaleLinear()
    .domain([0, 1]) // xG value range (0 to 1)
    .range(["white", "#BC0000"]); // White to Red color range

  var xGLegendGroup = svg.append("g")
    .attr("class", "legend")
    .attr("transform", "translate(" + xGLegendX + "," + xGLegendY + ")");

  // Create a rectangle for the xG legend
  xGLegendGroup.append("rect")
    .attr("width", xGLegendWidth)
    .attr("height", xGLegendHeight)
    .style("fill", "url(#xg-gradient)");

  // Add text label to the xG legend
  xGLegendGroup.append("text")
    .attr("x", xGLegendWidth / 2)
    .attr("y", -30)
    .attr("dy", "0.35em")
    .text("xG")
    .style("text-anchor", "middle")
    .style("font-size", "16px");

  xGLegendGroup.append("text")
    .attr("x", 3)
    .attr("y", -13) // Adjust the y position to move the text above the gradient scale
    .attr("dy", "0.35em")
    .text("0")
    .style("text-anchor", "middle")
    .style("font-size", "10px");

  xGLegendGroup.append("text")
    .attr("x", xGLegendWidth / 2)
    .attr("y", -13) // Adjust the y position to move the text above the gradient scale
    .attr("dy", "0.35em")
    .text("0.5")
    .style("text-anchor", "middle")
    .style("font-size", "10px");

  xGLegendGroup.append("text")
    .attr("x", xGLegendWidth - 3)
    .attr("y", -13) // Adjust the y position to move the text above the gradient scale
    .attr("dy", "0.35em")
    .text("1")
    .style("text-anchor", "middle")
    .style("font-size", "10px");

  var markerHeight = 4; // Height of the marker line
  var markerY = -6; // Y position of the marker line

  // Marker below 0
  xGLegendGroup.append("line")
    .attr("x1", 3)
    .attr("y1", markerY)
    .attr("x2", 3)
    .attr("y2", markerY + markerHeight)
    .style("stroke", "black")
    .style("stroke-width", 0.5);

  // Marker below 0.5
  xGLegendGroup.append("line")
    .attr("x1", xGLegendWidth / 2)
    .attr("y1", markerY)
    .attr("x2", xGLegendWidth / 2)
    .attr("y2", markerY + markerHeight)
    .style("stroke", "black")
    .style("stroke-width", 0.5);

    // Marker below 1
    xGLegendGroup.append("line")
      .attr("x1", xGLegendWidth - 3)
      .attr("y1", markerY)
      .attr("x2", xGLegendWidth - 3)
      .attr("y2", markerY + markerHeight)
      .style("stroke", "black")
      .style("stroke-width", 0.5);

    // Create a color gradient for the xG legend
    var xGGradient = xGLegendGroup.append("defs")
      .append("linearGradient")
      .attr("id", "xg-gradient")
      .attr("x1", "0%")
      .attr("x2", "110%")
      .attr("y1", "0%")
      .attr("y2", "0%");

    // Set the gradient stops based on the xG scale
    xGGradient.append("stop")
      .attr("offset", "0%")
      .style("stop-color", xGScale(0))
      .style("stop-opacity", 1);

    xGGradient.append("stop")
      .attr("offset", "100%")
      .style("stop-color", xGScale(1))
      .style("stop-opacity", 1);

    // Define the visual scale and color interpolation (white to blue)
    var visualScale = d3.scaleLinear()
      .domain([0, 1]) // Visual value range (0 to 1)
      .range(["white", "#0025B7"]); // White to Blue color range

    var visualLegendGroup = svg.append("g")
      .attr("class", "legend")
      .attr("transform", "translate(" + visualLegendX + "," + visualLegendY + ")");

    // Create a rectangle for the visual legend
    visualLegendGroup.append("rect")
      .attr("width", visualLegendWidth)
      .attr("height", visualLegendHeight)
      .style("fill", "url(#visual-gradient)");

    // Add text label to the visual legend
    visualLegendGroup.append("text")
      .attr("x", visualLegendWidth / 2)
      .attr("y", visualLegendHeight / 2)
      .attr("dy", "0.35em")

    // Create a color gradient for the visual legend
    var visualGradient = visualLegendGroup.append("defs")
      .append("linearGradient")
      .attr("id", "visual-gradient")
      .attr("x1", "0%")
      .attr("x2", "110%")
      .attr("y1", "0%")
      .attr("y2", "0%");

    // Set the gradient stops based on the visual scale
    visualGradient.append("stop")
      .attr("offset", "0%")
      .style("stop-color", visualScale(0))
      .style("stop-opacity", 1);

    visualGradient.append("stop")
      .attr("offset", "100%")
      .style("stop-color", visualScale(1))
      .style("stop-opacity", 1);
}

// RESET DROPDOWN OPTIONS
function resetDropdownOptions(selectId) {
  var select = document.getElementById(selectId);
  select.options.length = 0; // Clear all options
}

// UPDATE DROPDOWN OPTIONS
function updateDropdownOptions(selectId, options) {
  var select = document.getElementById(selectId);
  options.forEach(function(option) {
    var optionElem = document.createElement('option');
    optionElem.value = option;
    optionElem.text = option;
    select.appendChild(optionElem);
  });
document.getElementById('team-select').addEventListener('change', updatePlot);
document.getElementById('shot-type-select').addEventListener('change', updatePlot);
document.getElementById('player-select').addEventListener('change', updatePlot);
}
</script>
<script>
// SHOW PROGRESS BAR
window.addEventListener('scroll', function () {
  const scrollTop = document.documentElement.scrollTop || document.body.scrollTop;
  const scrollHeight = document.documentElement.scrollHeight || document.body.scrollHeight;
  const clientHeight = document.documentElement.clientHeight || document.body.clientHeight;
  const scrolled = (scrollTop / (scrollHeight - clientHeight)) * 100;
  document.querySelector('.progress-bar').style.width = scrolled + '%';
});

// FIX SLIDER CONTAINER POSITION TO THE TOP WHEN SCROLLED PAST
var sliderOffset = $('#slider-container').offset().top;
var sliderLeft = $('#slider-container').offset().left;
var threshold = -30; // Change this value to adjust when the fixed position is applied

$(window).on('resize', function() {
  sliderLeft = $('#slider-container').offset().left;
});

$(window).scroll(function() {
  if ($(window).scrollTop() > sliderOffset - threshold) {
    $('#slider-container').css({
      'position': 'fixed',
      'top': '0px',
      'left': sliderLeft,
      'background': '#ffffff' // Add a white background
    });
  } else {
    $('#slider-container').css({
      'position': 'static',
      'left': '0',
      'background': 'none' // Remove the background when not fixed
    });
  }
});
</script>
</body>
</html>